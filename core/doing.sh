#/bin/bash

# This runnable file checks if a new Job has arrived and automatically
# move it to the 'DOING' directory.
#
# Then it find the code file in the Job directory, creates a new
# directory named 'result' where it creates the files related to the
# output of the compiling command and the return code of the compiling
# process.
#
# Also executes the code with the input files received within the Job
# directory, then it creates files with the results and files with
# the error output of the code execution for each input received,
# then compares this files with the output files received within the
# Job directory. For each comparing process done, it creates a file
# with the differences between these output files.
#
# This runnable file creates judge files with the number code and the
# description related to this number according to the result got from
# the analysis of the diff files, for example, if the diff file
# related to the first input file got nothing on it, then it means
# the execution of the code is correct to that test case, which means
# the answer is right and the test case was accepted. In this case the
# judge file related to this test case receives the content "0 ACCEPTED"
# in case that diff file has something on it, it means it got wrong
# answer to that test case, then the judge file receives the content
# "1 WRONG ANSWER".
#
# All the generated files above are created within the 'result'
# directory.
#
# Finally it deletes the runnable file generated by the compiling
# process and moves the Job directory to the 'DONE' directory.
#
# If the 'DEBUG' flag is set to 1, messages that indicates the step
# by step of this runnable file are printed to the output environment.

# Global Options
DEBUG=1

# Compiles the problem code
function compile()
{
	pathc=$1
	old_dir=$(pwd)
	cd DOING/$pathc

	# find the code_file on the folder
	code_to_be_judged=( $(ls | grep *.c) )
	code_to_be_judged=${code_to_be_judged[0]}

	[ $DEBUG -eq 1 ] && echo "code to be judged=${code_to_be_judged}"

	mkdir result
	gcc ${code_to_be_judged} &> result/compile.out
	echo $? > result/compile.return
	cd ${old_dir}
}

function differ()
{
	arquivo=$1
	pathd=$2
	ext=`echo ${arquivo} | cut -d. -f2`

	[ $DEBUG -eq 1 ] && echo "Diff phase between: ${pathd}/out.${ext} and ${pathd}/result/stdout.${ext}"

	diff DOING/${pathd}/out.${ext} DOING/${pathd}/result/stdout.${ext} > DOING/${pathd}/result/diff.${ext}
}

function judge()
{
	arquivo=$1
	pathj=$2
	cd DOING

	ext=`echo ${arquivo} | cut -d. -f2`
	if [ `cat $pathj/result/diff.$ext | wc -l` -gt 0 ]
	then
		echo "1 WRONG ANSWER" > $pathj/result/judge.$ext
	else
		echo "0 ACCEPTED" > $pathj/result/judge.$ext
	fi
	cd ..
}

function execut()
{
	arquivo=$1
	pathe=$2
	old_dir=$(pwd)

	ext=`echo ${arquivo} | cut -d. -f2`
	cd DOING/$pathe

	[ $DEBUG -eq 1 ] && echo "Exec phase: stdout > result/stdout.$ext and stderr > result/stderr.$ext"

	cat ${arquivo} | ./a.out > result/stdout.$ext 2> result/stderr.$ext

	cd ${old_dir}
}

# ----------------------------------------------------------------------
# Main function of the script
# ----------------------------------------------------------------------

[ $DEBUG -eq 1 ] && echo "Starting the script..."

# Main loop: look for new jobs every X sec
while :; do

	sleep 5

	# if there are new jobs
	njobs=`ls JOBS | grep ^Job 2> /dev/null | wc -l`
	[ $DEBUG -eq 1 ] && echo "Number of Jobs: $njobs"

	if [ ${njobs} -gt 0 ]
	then
		path=`ls JOBS/ | head -1`
	        [ $DEBUG -eq 1 ] && echo "PATH=$path"

		mv JOBS/$path DOING/
		compile $path
		for i in `ls DOING/$path/ | grep -E ^in.*`;
		do
			execut $i $path
			differ $i $path
			judge $i $path
		done

        	[ $DEBUG -eq 1 ] && echo "Moving JOB to DONE folder"
		rm DOING/$path/a.out
	        mv DOING/$path DONE/


	else
		[ $DEBUG -eq 1 ] && echo "Nothing to be done (Sleeping...)"
	fi
done
