#/bin/bash

# This runnable file checks if a new Job has arrived and automatically
# move it to the 'DOING' directory.
#
# Then it find the code file in the Job directory, creates a new
# directory named 'result' where it creates the files related to the
# output of the compiling command and the return code of the compiling
# process.
#
# Also executes the code with the input files received within the Job
# directory, then it creates files with the results and files with
# the error output of the code execution for each input received,
# then compares this files with the output files received within the
# Job directory. For each comparing process done, it creates a file
# with the differences between these output files.
#
# This runnable file creates judge files with the number code and the
# description related to this number according to the result got from
# the analysis of the diff files, for example, if the diff file
# related to the first input file got nothing on it, then it means
# the execution of the code is correct to that test case, which means
# the answer is right and the test case was accepted. In this case the
# judge file related to this test case receives the content "0 ACCEPTED"
# in case that diff file has something on it, it means it got wrong
# answer to that test case, then the judge file receives the content
# "1 WRONG ANSWER".
#
# In case the code have compilation error, the functions execut, differ
# and judge do not run and is created a file named 'judge' inside the
# 'result' directory with the content "2 COMPILATION ERROR", which
# the errors can be seen in the file 'compile.out'. The function compile
# analyzes the return code of the compiling to determine if is a case of
# compilation error.
#
# In case the compilation of the code goes well and all that other files
# are generated by the functions execut, differ and judge, the function
# general_judge is runned to check if one of the judge files have a code
# "1" which means it is a wrong answer test case, if the function do not
# find any code "1" within all the judge files, a file named 'judge' is
# created and receives the content "0 ACCEPTED", in other case, the file
# receives the content "1 WRONG ANSWER".
#
# All the generated files above are created within the 'result'
# directory.
#
# Finally it deletes the runnable file generated by the compiling
# process and moves the Job directory to the 'DONE' directory.
#
# If the 'DEBUG' flag is set to 1, messages that indicates the step
# by step of this runnable file are printed to the output environment.

# Global Options
DEBUG=1
OUTPUT_SIZE_LIMIT=$((1024*1024+1))
CODE_SIZE_LIMIT=$((50*1024))
SLEEP_TIME=5
BASE_DIR=""
DEFAULT_MEMORY_LIMIT=$((50*1024)) # in KB

# This function finds the base directory for this script and goes to it!
#
# First it Checks the if the base directory is setted in the configuration file.
# Then, it checks if the directoris JOBS, DOING and DONE exists and if it
# is possible to write in there.
function goto_base_dir()
{
	[ "${BASE_DIR}" = "" ] && BASE_DIR=$( dirname $0 )

	cd ${BASE_DIR}

	for req_dir in "JOBS" "DOING" "DONE"; do
		if [ ! -d "${req_dir}" ] || [ ! -w "${req_dir}" ]
		then
			red_debug "Directory ${BASE_DIR}/${req_dir} not found or not writable. Exiting..."
			exit 0
		fi
	done
}


# This function compiles the problem code given within the Job directory
#
# First it Checks the size of the code file.
# Then, it finds the code file on the Job directory, generates two files named
# compile.out and compile.return in the 'result' directory which
# respectively have the output of the compiling command and the return
# code of the execution of the same command. The function then return
# this code too, indicating success or failure in compiling the code.
function compile()
{
	pathc=$1
	old_dir=$(pwd)
	cd DOING/$pathc

	# find the code_file on the folder
	code_to_be_judged=( $(ls | grep *.c) )
	code_to_be_judged=${code_to_be_judged[0]}

	[ $DEBUG -eq 1 ] && yellow_debug "code to be judged=${code_to_be_judged}"

	mkdir result

	# Code size limit
	code_size=$(l#/bin/bash

# This runnable file checks if a new Job has arrived and automatically
# move it to the 'DOING' directory.
#
# Then it find the code file in the Job directory, creates a new
# directory named 'result' where it creates the files related to the
# output of the compiling command and the return code of the compiling
# process.
#
# Also executes the code with the input files received within the Job
# directory, then it creates files with the results and files with
# the error output of the code execution for each input received,
# then compares this files with the output files received within the
# Job directory. For each comparing process done, it creates a file
# with the differences between these output files.
#
# This runnable file creates judge files with the number code and the
# description related to this number according to the result got from
# the analysis of the diff files, for example, if the diff file
# related to the first input file got nothing on it, then it means
# the execution of the code is correct to that test case, which means
# the answer is right and the test case was accepted. In this case the
# judge file related to this test case receives the content "0 ACCEPTED"
# in case that diff file has something on it, it means it got wrong
# answer to that test case, then the judge file receives the content
# "1 WRONG ANSWER".
#
# In case the code have compilation error, the functions execut, differ
# and judge do not run and is created a file named 'judge' inside the
# 'result' directory with the content "2 COMPILATION ERROR", which
# the errors can be seen in the file 'compile.out'. The function compile
# analyzes the return code of the compiling to determine if is a case of
# compilation error.
#
# In case the compilation of the code goes well and all that other files
# are generated by the functions execut, differ and judge, the function
# general_judge is runned to check if one of the judge files have a code
# "1" which means it is a wrong answer test case, if the function do not
# find any code "1" within all the judge files, a file named 'judge' is
# created and receives the content "0 ACCEPTED", in other case, the file
# receives the content "1 WRONG ANSWER".
#
# All the generated files above are created within the 'result'
# directory.
#
# Finally it deletes the runnable file generated by the compiling
# process and moves the Job directory to the 'DONE' directory.
#
# If the 'DEBUG' flag is set to 1, messages that indicates the step
# by step of this runnable file are printed to the output environment.

# Global Options
DEBUG=1
OUTPUT_SIZE_LIMIT=$((1024*1024+1))
CODE_SIZE_LIMIT=$((50*1024))
SLEEP_TIME=5
BASE_DIR=""
DEFAULT_MEMORY_LIMIT=$((50*1024)) # in KB

# This function finds the base directory for this script and goes to it!
#
# First it Checks the if the base directory is setted in the configuration file.
# Then, it checks if the directoris JOBS, DOING and DONE exists and if it
# is possible to write in there.
function goto_base_dir()
{
	[ "${BASE_DIR}" = "" ] && BASE_DIR=$( dirname $0 )

	cd ${BASE_DIR}

	for req_dir in "JOBS" "DOING" "DONE"; do
		if [ ! -d "${req_dir}" ] || [ ! -w "${req_dir}" ]
		then
			red_debug "Directory ${BASE_DIR}/${req_dir} not found or not writable. Exiting..."
			exit 0
		fi
	done
}


# This function compiles the problem code given within the Job directory
#
# First it Checks the size of the code file.
# Then, it finds the code file on the Job directory, generates two files named
# compile.out and compile.return in the 'result' directory which
# respectively have the output of the compiling command and the return
# code of the execution of the same command. The function then return
# this code too, indicating success or failure in compiling the code.
function compile()
{
	pathc=$1
	old_dir=$(pwd)
	cd DOING/$pathc

	# find the code_file on the folder
	code_to_be_judged=( $(ls | grep *.c) )
	code_to_be_judged=${code_to_be_judged[0]}

	[ $DEBUG -eq 1 ] && yellow_debug "code to be judged=${code_to_be_judged}"

	mkdir result

	# Code size limit
	code_size=$(l